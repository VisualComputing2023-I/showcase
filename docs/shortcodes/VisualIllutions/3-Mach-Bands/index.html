<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="3 - Mach Bands # Ejercicio Desarrolle una aplicación de visualización de terrenos. Revise el tutorial de Coding Train sobre la generación de terrenos en 3D con ruido de Perlin.
Introducción # La visualización de terrenos se ha realizado por muchos años mediante modos tradicionales con dibujos en representaciones planas en 2D para fines militares y de estudio de la geografía. Pero con la llegada de la computación y la capacidad de generar imagenes en 3D, se desarrollaron diferentes técnicas para poder visualizar y crear terrenos para no solo los mismos fines sino también otros como los videojuegos y los simuladores de vuelos."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="3 - Mach Bands # Ejercicio Desarrolle una aplicación de visualización de terrenos. Revise el tutorial de Coding Train sobre la generación de terrenos en 3D con ruido de Perlin.
Introducción # La visualización de terrenos se ha realizado por muchos años mediante modos tradicionales con dibujos en representaciones planas en 2D para fines militares y de estudio de la geografía. Pero con la llegada de la computación y la capacidad de generar imagenes en 3D, se desarrollaron diferentes técnicas para poder visualizar y crear terrenos para no solo los mismos fines sino también otros como los videojuegos y los simuladores de vuelos."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing2023-i.github.io/showcase/docs/shortcodes/VisualIllutions/3-Mach-Bands/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-29T05:35:50-05:00"><title>3 Mach Bands | Visual Computing 2023 I</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing 2023 I</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><input type=checkbox id=section-ec67a64aba70b9df3d2a9acd6c92e3bc class=toggle>
<label for=section-ec67a64aba70b9df3d2a9acd6c92e3bc class="flex justify-between"><a href=/showcase/docs/shortcodes/p5/>P5</a></label><ul><li><a href=/showcase/docs/shortcodes/p5/iframe/>Iframe</a></li><li><a href=/showcase/docs/shortcodes/p5/div/>Div</a></li></ul></li><li><input type=checkbox id=section-5e90dfc1cda674fda3ec0abb0b45bf6a class=toggle>
<label for=section-5e90dfc1cda674fda3ec0abb0b45bf6a class="flex justify-between"><a href=/showcase/docs/shortcodes/team/>Team</a></label><ul><li><a href=/showcase/docs/shortcodes/team/Diego-Alvarado/>Diego Alvarado</a></li><li><a href=/showcase/docs/shortcodes/team/Juli%C3%A1n-Manosalva/>Julián Manosalva</a></li><li><a href=/showcase/docs/shortcodes/team/Sebasti%C3%A1n-Pach%C3%B3n/>Sebastián Pachón</a></li></ul></li><li><input type=checkbox id=section-94839c8d59cd3fd9e827edbeb4e69371 class=toggle checked>
<label for=section-94839c8d59cd3fd9e827edbeb4e69371 class="flex justify-between"><a href=/showcase/docs/shortcodes/VisualIllutions/>Visual Illutions</a></label><ul><li><a href=/showcase/docs/shortcodes/VisualIllutions/1-Visual-Illutions/>1 Visual Illutions</a></li><li><a href=/showcase/docs/shortcodes/VisualIllutions/2-Masking/>2 Masking</a></li><li><a href=/showcase/docs/shortcodes/VisualIllutions/3-Mach-Bands/ class=active>3 Mach Bands</a></li></ul></li></ul></li></ul><ul><li><a href=/showcase/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>3 Mach Bands</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#3---mach-bands>3 - Mach Bands</a></li><li><a href=#introducción><strong>Introducción</strong></a></li><li><a href=#antecedentes-y-trabajo-previo><strong>Antecedentes y trabajo previo</strong></a><ul><li><a href=#visualización>Visualización</a><ul><li><a href=#optimización-lod>Optimización (LOD)</a></li></ul></li><li><a href=#generación-de-terreno>Generación de Terreno</a></li></ul></li><li><a href=#solución>Solución</a><ul><li><a href=#terreno-usando-un-fractal-plasma>Terreno usando un fractal plasma</a></li><li><a href=#terreno-generado-usando-ruido-de-perlin>Terreno generado usando Ruido de Perlin</a></li></ul></li><li><a href=#conclusiones><strong>Conclusiones</strong></a></li><li><a href=#trabajo-futuro><strong>Trabajo futuro</strong></a></li><li><a href=#referencias><strong>Referencias</strong></a></li></ul></nav></aside></header><article class=markdown><h1 id=3---mach-bands>3 - Mach Bands
<a class=anchor href=#3---mach-bands>#</a></h1><blockquote class="book-hint info"><p><b>Ejercicio</b>
Desarrolle una aplicación de visualización de terrenos. Revise el tutorial de Coding Train sobre la generación de terrenos en 3D con ruido de Perlin.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/IKB1hWWedMk style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="3D terrain generation with Perlin noise"></iframe></div></blockquote><h1 id=introducción><strong>Introducción</strong>
<a class=anchor href=#introducci%c3%b3n>#</a></h1><p>La visualización de terrenos se ha realizado por muchos años mediante modos tradicionales con dibujos en representaciones planas en 2D para fines militares y de estudio de la geografía. Pero con la llegada de la computación y la capacidad de generar imagenes en 3D, se desarrollaron diferentes técnicas para poder visualizar y crear terrenos para no solo los mismos fines sino también otros como los videojuegos y los simuladores de vuelos.</p><h1 id=antecedentes-y-trabajo-previo><strong>Antecedentes y trabajo previo</strong>
<a class=anchor href=#antecedentes-y-trabajo-previo>#</a></h1><h2 id=visualización>Visualización
<a class=anchor href=#visualizaci%c3%b3n>#</a></h2><p>Para la visualización de terrenos lo primero que se usaba eran los Modelos Digitales de Terrenos (DTM por las siglas en ingles) los cuales se usaban para representar partes de la superficie del suelo de manera digital. Historicamente los DTM fueron introducidos por ingenierso del MIT a finales de los años 50&rsquo;s. La definición de estos modelos es simplemente una representación estadística de la superficie continua de la tierra por un numero muy grande de puntos seleccionados con coordenadas x,y,z conocidas y en un campo de coordenadas arbitrario. También existen otros terminos como Modelo Digital de Elevación. (DEM), Modelo Digital de Altura (DHM), Modelo Digital del Suelo (DGM) y Datos Digitales de Elevación del Terreno (DTED). A pesar de los diferentes términos, todos representan la topografía de la tierra. [1]</p><p>Para poder organizar los datos que pueden ser regulares o irregulares se usan diferentes estructuras de datos, tales como cuadriculas/tramas (matrices), quadtrees, arboles binarios de triangulos u otras estructuras para datos de triangulos irregulares.</p><ul><li><p>Al usar las cuadriculas o tramas, se tiene la ventaja de que estas son las más sencillas de usar ya que son matrices y los puntos vecinos estan definidos de manera implícita. Pero su mayor problema es que usualmente requiere mucho espacio de almacenamiento y hay muchos datos rebundantes de datos en terrenos planos.</p></li><li><p>Los quadtrees (arboles donde cada nodo puede tener hasta 4 nodos hijos) fueron bastante populares para los DTM y los Sistemas de Información Geográfica (GIS) a finales del siglo pasado. La idea es tener como elementos primitivos cuadrados, los cuales se pueden dividir internamente en más cuadrados (dividir en 4 nodos hijos) y así recursivamente. Esto por lo tanto permite eliminar la información rebundante en terrenos planos, pero sigue teniendo el problema que al ser cuadrados es cómo una cuadricula simplificada y para datos que sean continuos no es efectivo.</p></li><li><p>La Red de Triangulos Irregulares (TIN) es una estructura bastante usada para modelamiento de terrenos ya que permite usar datos continuos de manera directa. A diferencia de las cuadriculas se tienen que especificar las relaciones entre puntos vecinos de manera explícita. [2]</p></li><li><p>Las herarquias de triangulos rectángulos (HRT) son similares a los quadtrees, pero en este se usan normalmente arboles binarios donde al inicio tenemos una baldosa raíz la cual salen dos triangulos rectangulos (la división de un cuadrado en dos triangulos trazando una linea por la diagonal). Cada triangulo puede dividirse por la mitad para obtener dos triangulos hijos y así recursivamente hasta tener el nivel de detalle necesario.</p></li></ul><h3 id=optimización-lod>Optimización (LOD)
<a class=anchor href=#optimizaci%c3%b3n-lod>#</a></h3><p>Un tema interesante respecto a la visualización de terrenos es su optimización debido a la gran cantidad de puntos que se intentan renderizar. Una de las técnicas que existen para reducir el trabajo que se tiene que realizar es el nivel de detalle (LOD) el cual tiene como idea principal reducir la cantidad de triangulos que tienen los puntos más alejados de la camara.
Para lograr esto se tienen diferentes métodos como usar HRT o quadtrees e ir aumentando la cantidad de hijos para los nodos que esten más cerca de la cámara o usar una TIN la cuale es una estructura con muy buen rendimiento inclusive mejor que las HRT, pero que usarla de manera general es más dificil y requiere soporte de geometría de multiresolución. Existen otros algoritmos pensados en optimizar aún más los rendimientos como las Mallas Dinámicas Adaptativas por Lotes (BDAM) las cuales buscan combinar las propiedades de las HRT y las TIN para buscar un mejor rendimiento [3] o como el método de Adaptación Óptima en Tiempo Real (ROAM) el cual usa dos colas de prioridad para realizar las operaciones de union y division que mantienen triangulaciones continuas en arboles binarios de triangulos pre procesados. [4]</p><h2 id=generación-de-terreno>Generación de Terreno
<a class=anchor href=#generaci%c3%b3n-de-terreno>#</a></h2><p>En diferentes juegos 3D y aplicaciones se usan terrenos generados de manera aleatoria. Para lograr que estos se parezcan a los de la vida real no se pueden simplemente asignar números aleatorios a las alturas, asi que una forma sencilla de generarlos es usando fractales y los Fractales con Movimiento Browniano (FBM) son unos fractales que tienen un fondo matemático riguroso y tienen buenas propiedades matemáticas que permiten usarlos de manera facil. [5].</p><p>La idea central de de un fractal FBM es combinar diferentes tipos de funciones de ruido. Con ruido no se habla del ruido blanco sino de un tipo de ruido llamado ruido rosa (pink noise). La primera persona en usar este tipo de ruido en computación gráfica fue Ken Perlin al crear su famosa función de ruido (la cual es la que usa P5 cuando se llama la funcion noise()), con la cual ganó un premio oscar. Para crear ruido rosa en una dimensión lo que se hace es definir que tanto se mueve en x (frecuencia) y por cada x se genera un numero aleatorio, luego se hacer interpolación lineal entre estos puntos aleatorios. Un FBM se puede generar facilmente creando varias funciones de ruido rosa con diferentes frecuencias y luego se suman los resultados. La función de ruido de perlin usa este mismo principio, pero esta mucho más desarrollada y ha tenido diferentes mejoras con el tiempo.</p><h1 id=solución>Solución
<a class=anchor href=#soluci%c3%b3n>#</a></h1><h2 id=terreno-usando-un-fractal-plasma>Terreno usando un fractal plasma
<a class=anchor href=#terreno-usando-un-fractal-plasma>#</a></h2><p>Para este ejemplo de un terreno usando un fractal se usó un fractal plasma, usando como base la implementación en JavaScript de este fractal hecha por Piotr Rochala (<a href=http://rocha.la/>http://rocha.la/</a>) la cual se modificó un poco para poder ser usada para generar terrenos.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>eso</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>$plasma</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>eso</span>.<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>w</span>,<span style=color:#a6e22e>h</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>yoff</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>rows</span>; <span style=color:#f92672>++</span><span style=color:#a6e22e>y</span>){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>xoff</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>cols</span>; <span style=color:#f92672>++</span><span style=color:#a6e22e>x</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>landscape</span>[<span style=color:#a6e22e>y</span>][<span style=color:#a6e22e>x</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>eso</span>.<span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>yoff</span>][<span style=color:#a6e22e>xoff</span>], <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>max_min</span>, <span style=color:#a6e22e>max_min</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xoff</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>smooth_slider</span>.<span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>yoff</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>smooth_slider</span>.<span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><iframe id=terrain2 style=width:630px;height:630px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/terrain2.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=terreno-generado-usando-ruido-de-perlin>Terreno generado usando Ruido de Perlin
<a class=anchor href=#terreno-generado-usando-ruido-de-perlin>#</a></h2><p>Esto código fue hecho basado en el código del video de The Coding Train mencionado arriba del articulo. Para este generador de terreno lo principal es generar una malla de triangulos y luego asignarle las alturas usando la función de ruido de perlin y variando yoff y xoff. Para generar el movimiento simplemente se aumenta el valor por defecto de yoff cada iteración de draw.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>flying</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>flying_slider</span>.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>/</span><span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>yoff</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>flying</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>rows</span>; <span style=color:#f92672>++</span><span style=color:#a6e22e>y</span>){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>xoff</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>cols</span>; <span style=color:#f92672>++</span><span style=color:#a6e22e>x</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>landscape</span>[<span style=color:#a6e22e>y</span>][<span style=color:#a6e22e>x</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>noise</span>(<span style=color:#a6e22e>xoff</span>,<span style=color:#a6e22e>yoff</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>max_min</span>, <span style=color:#a6e22e>max_min</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xoff</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.05</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>yoff</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.05</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><iframe id=terrain1 style=width:630px;height:630px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/terrain1.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h1 id=conclusiones><strong>Conclusiones</strong>
<a class=anchor href=#conclusiones>#</a></h1><ul><li>Como se esperaba, generar un terreno usando el ruido de perlin es más fácil de controlar que usando una función de fractal o de FBM</li><li>Si bien usar una cuadrícula no es la manera más óptima de guardar información de superficies, es lo suficientemente buena para generación de terrenos simples usando ruido de perlin.</li></ul><h1 id=trabajo-futuro><strong>Trabajo futuro</strong>
<a class=anchor href=#trabajo-futuro>#</a></h1><p>Aún se siguen desarrollando nuevos algoritmos que logren mejorar el rendimiento para renderizar terrenos, ya que este problema es uno muy interesante que requiere usos creativos de estructuras de datos, análisis de redes de tríangulos irregulares, manejo de memoria y optimización pensada para la CPU y la GPU.</p><p>Además, respecto a la generación procedural de terrenos, es posible lograr terrenos aleatorios muy realistas usando otros modelos, pero en especial se podría usar inteligencía artificial para poder lograr conseguir terrenos hyperrealistas que serían muy utiles para investigación. También se pueden aplicar los conceptos de estos modelos para generar otro tipo de estructuras, ya que por ejemplo el concepto de LOD no es solo de terrenos sino también todos los objetos 3D de un escenario, por lo tanto algunas ideas y algoritmos usados en este campo pueden ser aplicadas en otros para mejorar rendimientos o mejorar eficiencia en memoria.</p><h1 id=referencias><strong>Referencias</strong>
<a class=anchor href=#referencias>#</a></h1><p>[1] Alias Abdul Rahman, Digital Terrain Model Data Structures, Jabatan Geoinformatik, Fakulti Ukur Universi!i Teknologi Malaysia, Buletin Ukur, Jld. 5, No.1, ms. 61-72,1994</p><p>[2] R. J. Fowler and J. J. Little. Automatic extraction of irregular network digital terrain models. Computer Graphics, 13(2):199-207, August 1979.</p><p>[3] P. Cignoni, F. Ganovelli, E. Gobbetti‡, F. Marton, F. Ponchio, R. Scopigno. BDAM–BatchedDynamic Adaptive Meshes for High Performance Terrain Visualization, Volume 22 (2003), Number 3, 2003.</p><p>[4] M. Duchaineau, M. Wolinsky, D. E. Sigeti, M. C. Miller, C. Aldrich and M. B. Mineev-Weinstein, &ldquo;ROAMing terrain: Real-time Optimally Adapting Meshes,&rdquo; Proceedings. Visualization &lsquo;97 (Cat. No. 97CB36155), Phoenix, AZ, USA, 1997, pp. 81-88, doi: 10.1109/VISUAL.1997.663860.</p><p>[5] M. A. DeLoura, Game programming gems 2. Hingham, Mass: Charles River Media, 2001.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://jupachonc.github.io/showcase/commit/3635e451b18c74fa8bd7e93b409794e140c23f05 title='Last modified by dalvaradoc | March 29, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 29, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#3---mach-bands>3 - Mach Bands</a></li><li><a href=#introducción><strong>Introducción</strong></a></li><li><a href=#antecedentes-y-trabajo-previo><strong>Antecedentes y trabajo previo</strong></a><ul><li><a href=#visualización>Visualización</a><ul><li><a href=#optimización-lod>Optimización (LOD)</a></li></ul></li><li><a href=#generación-de-terreno>Generación de Terreno</a></li></ul></li><li><a href=#solución>Solución</a><ul><li><a href=#terreno-usando-un-fractal-plasma>Terreno usando un fractal plasma</a></li><li><a href=#terreno-generado-usando-ruido-de-perlin>Terreno generado usando Ruido de Perlin</a></li></ul></li><li><a href=#conclusiones><strong>Conclusiones</strong></a></li><li><a href=#trabajo-futuro><strong>Trabajo futuro</strong></a></li><li><a href=#referencias><strong>Referencias</strong></a></li></ul></nav></div></aside></main></body></html>